% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Searching-Sampling.R
\name{Searching.Sampling}
\alias{Searching.Sampling}
\title{Searching-Sampling method}
\usage{
Searching.Sampling(
  Y,
  D,
  Z,
  X,
  intercept = TRUE,
  alpha = 0.05,
  alpha0 = 0.01,
  Sampling = TRUE,
  boot.value = TRUE,
  M = 1000,
  max_clique = FALSE
)
}
\arguments{
\item{Y}{continuous and non-missing, n by 1 numeric outcome vector.}

\item{D}{continuous or discrete, non-missing, n by 1 numeric treatment vector.}

\item{Z}{continuous or discrete, non-missing, n by p_z numeric instrument matrix, containing p_z instruments.}

\item{X}{optional,continuous or discrete, n by p_x numeric covariate matrix, containing p_z covariates.}

\item{intercept}{a boolean scalar indicating to include the intercept or not, with default TRUE.}

\item{alpha}{a numeric scalar value between 0 and 1 indicating the significance level for the confidence interval, with default 0.05.}

\item{alpha0}{a numeric scalar value between 0 and 1 indicating the sampling threshold level for the generated samples, with default 0.01.}

\item{Sampling}{a boolean scalar indicating to implement Sampling method, with default TRUE.}

\item{boot.value}{a boolean scalar indicating to implement bootstrap, with default TRUE.}

\item{M}{a positive integer indicating the number of bootstrap resampling for computing the confidence interval, with default 1000.}

\item{max_clique}{an option to replace the majority and plurality voting procedures with finding maximal clique in the IV voting matrix, with default FALSE.}
}
\value{
\item{\code{CI}}{a two dimensional numeric vector denoting the 1-alpha confidence intervals for betaHat with lower and upper endpoints.}
\item{\code{rule}}{a boolean scalar denoting whether the identification condition is satisfied or not}
\item{\code{VHat}}{a numeric vector denoting the set of valid and relevant IVs.}
}
\description{
Construction of confidence intervals with Searching-Sampling method
}
\examples{
\dontrun{
### example ###

A1gen<-function(rho,p){
  A1=matrix(0,p,p)
  for(i in 1:p){
   for(j in 1:p){
      A1[i,j]<-rho^(abs(i-j))
    }
  }
  A1
}

### Set the model parameter ###
n: sample size
IV.str: individual IV strength
VIO.str: violation strength
beta:   true treatment effect (set at 1)
px:number of covariates
L: number of candiate IVs
n = 500;
IV.str=0.5;
VIO.str=0.4;
pi.value<-IV.str*VIO.str
beta = 1;
px <- 10;
L = 10;
p=L+px
phi<-rep(0,px)
psi<-rep(0,px)
phi[1:px]<-(1/px)*seq(1,px)+0.5
psi[1:px]<-(1/px)*seq(1,px)+1
rho=0.5
Cov<-(A1gen(rho,p))

### Generate a setting where only the plurality rule holds
# 6 invalid IVs and 4 valid IVs
s1 = 3;
s2 = 3;
s=s1+s2
alpha = c(rep(0,L-s),rep(pi.value,s1),-seq(1,s2)/2);
gamma=rep(IV.str,L)

epsilonSigma = matrix(c(1,0.8,0.8,1),2,2)
W<-mvrnorm(n, rep(0, p), Cov)
Z=W[,1:L]
X=W[,(L+1):p]
epsilonSigma = matrix(c(1,0.8,0.8,1),2,2)
epsilon = mvrnorm(n,rep(0,2),epsilonSigma)
D = 0.5 + Z \%*\% gamma+ X\%*\% psi + epsilon[,1]
Y = -0.5 + Z \%*\% alpha + D * beta + X\%*\%phi+ epsilon[,2]
Searching.Sampling(Y,D,Z,X)
Searching.Sampling(Y,D,Z,X,Sampling=FALSE)
}
}
