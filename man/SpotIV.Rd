% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/SpotIV.R
\name{SpotIV}
\alias{SpotIV}
\title{SpotIV method for causal inference in nonlinear outcome models}
\usage{
SpotIV(
  Y,
  D,
  Z,
  X = NULL,
  bs.Niter = 40,
  M = 2,
  M.est = T,
  V = NULL,
  intercept = T,
  d1,
  d2,
  w0,
  bw = NULL,
  parallel = F
)
}
\arguments{
\item{Y}{continuous or discrete and non-missing, n by 1 numeric outcome vector.}

\item{D}{continuous and non-missing, n by 1 numeric treatment vector.}

\item{Z}{continuous or discrete, non-missing, n by pz numeric instrument matrix, containing pz instruments.}

\item{X}{continuous or discrete, n by px numeric baseline covariates.}

\item{bs.Niter}{a positive integer indicating the number of bootstrap resampling for computing the confidence interval.}

\item{M}{an integer 1<=M<=3, the dimension of indices in the outcome model. Default is 3.}

\item{M.est}{True or False, whether estimate M based on BIC. Default is True.}

\item{V}{the set of valid IVs for implementing the oracle control function method}

\item{intercept}{a boolean scalar indicating to include the intercept or not. Default is TRUE.}

\item{d1}{a scalar for computing CATE(d1,d2|w0).}

\item{d2}{a scalar for computing CATE(d1,d2|w0).}

\item{w0}{a (pz+px) by 1 vector for computing CATE(d1,d2|w0).}

\item{bw}{a (M+1) by 1 vector bandwidth specification. Default is NULL and the bandwidth is chosen by rule of thumb.}

\item{parallel}{True or False indicating whether to use parallel computing (maybe useless on Windows). Default is False.}
}
\value{
\item{\code{SHat}}{a numeric vector denoting the set of relevant IVs.}
    \item{\code{cateHat}}{a numeric scalar denoting the estimate of CATE(d1,d2|w0).}
    \item{\code{cate.sdHat}}{a numeric scalar denoting the estimated standard deviation of cateHat.}
    \item{\code{Maj.pass}}{True or False indicating whether the majority rule test is passed or not.}
}
\description{
Causal inference in nonlinear outcome model with possibly invalid IVs under the majority rule. The parallel computation depends on R packages "foreach" and "doParallel".
}
\examples{
\dontrun{
### Working Low Dimensional Example ###
library(mvtnorm)
library(MASS)
library(Matrix)
n = 500; J = 7; s = 5; d1=-1; d2=1; z0=c(rep(0, J-1),0.1)
Z <- matrix(rnorm(n * J, 0, 1) , ncol = J, nrow = n)
gam <- c(rep(0.8, floor(J / 2)), rep(-0.8, J - floor(J / 2)))
cov.noise<-matrix(c(1,0.25, 0.25, 1),ncol=2)
noise.vec<-rmvnorm(n, rep(0,2), cov.noise)
v.vec<-noise.vec[,1]
X<-matrix(runif(n*2), ncol=2)
D = 0.5+Z \%*\% gam + v.vec
pi0 <- c(rep(0, s), 0.8, 0.4)
beta0 <- 0.25
u.vec<- noise.vec[,2]
Y = (-0.5 + Z \%*\% pi0 + D * beta0 + u.vec>=0)
u1.r<-rnorm(2000,0,sd=1)
cace0 <- mean((as.numeric(-0.5+d1 * beta0 + z0 \%*\% pi0)+ u1.r )>=0) - mean((as.numeric(-0.5+d2 * beta0 + z0 \%*\% pi0) + u1.r)>=0)
library(foreach)
library(doParallel)
registerDoParallel(4)
system.time(re1<-SpotIV(Y=Y, D=D, Z=Z, X=NULL, bs.Niter = 40, d1 = d1, d2 = d2, w0 = z0, parallel=T))
system.time(re2<-SpotIV(Y=Y, D=D, Z=Z, X=NULL, bs.Niter = 40, d1 = d1, d2 = d2, w0 = z0, parallel=F))
}



}
