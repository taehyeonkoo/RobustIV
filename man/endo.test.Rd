% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/endo-test.R
\name{endo.test}
\alias{endo.test}
\title{Endogeneity-test}
\usage{
endo.test(
  Y,
  D,
  Z,
  X,
  intercept = TRUE,
  alpha = 0.05,
  tuning = 2.01,
  method = "DeLasso",
  invalid = TRUE,
  max_clique = FALSE
)
}
\arguments{
\item{Y}{continuous and non-missing, n by 1 numeric outcome vector.}

\item{D}{continuous or discrete, non-missing, n by 1 numeric treatment vector.}

\item{Z}{continuous or discrete, non-missing, n by p_z numeric instrument matrix, containing p_z instruments.}

\item{X}{optional,continuous or discrete, n by p_x numeric covariate matrix, containing p_z covariates.}

\item{intercept}{a boolean scalar indicating to include the intercept or not, with default TRUE.}

\item{alpha}{a numeric scalar value between 0 and 1 indicating the significance level for the confidence interval, with default 0.05.}

\item{tuning}{a numeric scalar value tuning parameter for TSHT greater 2, with default 2.01.}

\item{method}{a character scalar declaring the method used to estimate the inputs in TSHT, "OLS" works for ordinary least square and "DeLasso" works for high dimension. (default = "DeLasso")}

\item{invalid}{a boolean scalar asking to assume that there are some invalid instrument variables with TRUE/FALSE (default = TRUE)}

\item{max_clique}{an option to replace the majority and plurality voting procedures with finding maximal clique in the IV voting matrix, with default FALSE.}
}
\value{
\item{\code{VHat}}{numeric vector : the estimated set of relevant and vaild IVs}
   \item{\code{Q}}{numeric value : our endogeneity test statistic}
   \item{\code{Sigma12}}{numeric value : estimated covaraince}
}
\description{
Endogneity test function, which provides the robust inference of the treatment effect in the presence of invalid instrumental variables in both low-dimensional and high-dimensional settings.
}
\examples{



library(MASS)
library(RobustIV)

## Generate the data
n = 300; L = 400; s = 3; nRelevant = 10
alpha = c(rep(3,s),rep(0,L-s)); beta = 1; gamma = c(rep(1,nRelevant),rep(0,L-nRelevant))
epsilonSigma = matrix(c(1,0.8,0.8,1),2,2)
Z = matrix(rnorm(n*L),n,L)
epsilon = mvrnorm(n,rep(0,2),epsilonSigma)
D =  0.5 + Z \%*\% gamma + epsilon[,1]
Y = -0.5 + Z \%*\% alpha + D * beta + epsilon[,2]

## Implement the endogeneity test

endo.test(Y,D,Z)
endo.test(Y,D,Z,max_clique = TRUE)



}
